// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: prototype/service.proto

package prototype

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RaidoChainClient is the client API for RaidoChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RaidoChainClient interface {
	// GetUTxO get all unspent transaction outputs of given address
	GetUTxO(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*UTxOResponse, error)
	// GetStatus returns node status
	GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusResponse, error)
	// GetBlockByNum returns block with given number or error if not found.
	GetBlockByNum(ctx context.Context, in *NumRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	// GetBlockByHash returns block with given hash or error if not found.
	GetBlockByHash(ctx context.Context, in *HashRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	// GetBalance returns address balance.
	GetBalance(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*NumberResponse, error)
	// GetTransaction returns transaction with given hash.
	GetTransaction(ctx context.Context, in *HashRequest, opts ...grpc.CallOption) (*TransactionResponse, error)
	// GetStakeDeposits get all unspent transaction outputs of given address
	GetStakeDeposits(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*UTxOResponse, error)
	// GetTransactionsCount get number of transactions sent by given address.
	GetTransactionsCount(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*NumberResponse, error)
	// GetBlocksStartCount gets a number of blocks starting from a specific block
	GetBlocksStartCount(ctx context.Context, in *BlocksStartCountRequest, opts ...grpc.CallOption) (*BlocksStartCountResponse, error)
	// ListValidators returns validator addresses
	ListValidators(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ValidatorAddressesResponse, error)
}

type raidoChainClient struct {
	cc grpc.ClientConnInterface
}

func NewRaidoChainClient(cc grpc.ClientConnInterface) RaidoChainClient {
	return &raidoChainClient{cc}
}

func (c *raidoChainClient) GetUTxO(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*UTxOResponse, error) {
	out := new(UTxOResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetUTxO", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) GetStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) GetBlockByNum(ctx context.Context, in *NumRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetBlockByNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) GetBlockByHash(ctx context.Context, in *HashRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetBlockByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) GetBalance(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*NumberResponse, error) {
	out := new(NumberResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) GetTransaction(ctx context.Context, in *HashRequest, opts ...grpc.CallOption) (*TransactionResponse, error) {
	out := new(TransactionResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) GetStakeDeposits(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*UTxOResponse, error) {
	out := new(UTxOResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetStakeDeposits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) GetTransactionsCount(ctx context.Context, in *AddressRequest, opts ...grpc.CallOption) (*NumberResponse, error) {
	out := new(NumberResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetTransactionsCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) GetBlocksStartCount(ctx context.Context, in *BlocksStartCountRequest, opts ...grpc.CallOption) (*BlocksStartCountResponse, error) {
	out := new(BlocksStartCountResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/GetBlocksStartCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raidoChainClient) ListValidators(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ValidatorAddressesResponse, error) {
	out := new(ValidatorAddressesResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.RaidoChain/ListValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaidoChainServer is the server API for RaidoChain service.
// All implementations must embed UnimplementedRaidoChainServer
// for forward compatibility
type RaidoChainServer interface {
	// GetUTxO get all unspent transaction outputs of given address
	GetUTxO(context.Context, *AddressRequest) (*UTxOResponse, error)
	// GetStatus returns node status
	GetStatus(context.Context, *emptypb.Empty) (*StatusResponse, error)
	// GetBlockByNum returns block with given number or error if not found.
	GetBlockByNum(context.Context, *NumRequest) (*BlockResponse, error)
	// GetBlockByHash returns block with given hash or error if not found.
	GetBlockByHash(context.Context, *HashRequest) (*BlockResponse, error)
	// GetBalance returns address balance.
	GetBalance(context.Context, *AddressRequest) (*NumberResponse, error)
	// GetTransaction returns transaction with given hash.
	GetTransaction(context.Context, *HashRequest) (*TransactionResponse, error)
	// GetStakeDeposits get all unspent transaction outputs of given address
	GetStakeDeposits(context.Context, *AddressRequest) (*UTxOResponse, error)
	// GetTransactionsCount get number of transactions sent by given address.
	GetTransactionsCount(context.Context, *AddressRequest) (*NumberResponse, error)
	// GetBlocksStartCount gets a number of blocks starting from a specific block
	GetBlocksStartCount(context.Context, *BlocksStartCountRequest) (*BlocksStartCountResponse, error)
	// ListValidators returns validator addresses
	ListValidators(context.Context, *emptypb.Empty) (*ValidatorAddressesResponse, error)
	mustEmbedUnimplementedRaidoChainServer()
}

// UnimplementedRaidoChainServer must be embedded to have forward compatible implementations.
type UnimplementedRaidoChainServer struct {
}

func (UnimplementedRaidoChainServer) GetUTxO(context.Context, *AddressRequest) (*UTxOResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUTxO not implemented")
}
func (UnimplementedRaidoChainServer) GetStatus(context.Context, *emptypb.Empty) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedRaidoChainServer) GetBlockByNum(context.Context, *NumRequest) (*BlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByNum not implemented")
}
func (UnimplementedRaidoChainServer) GetBlockByHash(context.Context, *HashRequest) (*BlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByHash not implemented")
}
func (UnimplementedRaidoChainServer) GetBalance(context.Context, *AddressRequest) (*NumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedRaidoChainServer) GetTransaction(context.Context, *HashRequest) (*TransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedRaidoChainServer) GetStakeDeposits(context.Context, *AddressRequest) (*UTxOResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStakeDeposits not implemented")
}
func (UnimplementedRaidoChainServer) GetTransactionsCount(context.Context, *AddressRequest) (*NumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionsCount not implemented")
}
func (UnimplementedRaidoChainServer) GetBlocksStartCount(context.Context, *BlocksStartCountRequest) (*BlocksStartCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlocksStartCount not implemented")
}
func (UnimplementedRaidoChainServer) ListValidators(context.Context, *emptypb.Empty) (*ValidatorAddressesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidators not implemented")
}
func (UnimplementedRaidoChainServer) mustEmbedUnimplementedRaidoChainServer() {}

// UnsafeRaidoChainServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RaidoChainServer will
// result in compilation errors.
type UnsafeRaidoChainServer interface {
	mustEmbedUnimplementedRaidoChainServer()
}

func RegisterRaidoChainServer(s grpc.ServiceRegistrar, srv RaidoChainServer) {
	s.RegisterService(&RaidoChain_ServiceDesc, srv)
}

func _RaidoChain_GetUTxO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetUTxO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetUTxO",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetUTxO(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_GetBlockByNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetBlockByNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetBlockByNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetBlockByNum(ctx, req.(*NumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_GetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetBlockByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetBlockByHash(ctx, req.(*HashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetBalance(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetTransaction(ctx, req.(*HashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_GetStakeDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetStakeDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetStakeDeposits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetStakeDeposits(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_GetTransactionsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetTransactionsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetTransactionsCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetTransactionsCount(ctx, req.(*AddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_GetBlocksStartCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlocksStartCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).GetBlocksStartCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/GetBlocksStartCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).GetBlocksStartCount(ctx, req.(*BlocksStartCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaidoChain_ListValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaidoChainServer).ListValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.RaidoChain/ListValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaidoChainServer).ListValidators(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// RaidoChain_ServiceDesc is the grpc.ServiceDesc for RaidoChain service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RaidoChain_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rdo.service.RaidoChain",
	HandlerType: (*RaidoChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUTxO",
			Handler:    _RaidoChain_GetUTxO_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _RaidoChain_GetStatus_Handler,
		},
		{
			MethodName: "GetBlockByNum",
			Handler:    _RaidoChain_GetBlockByNum_Handler,
		},
		{
			MethodName: "GetBlockByHash",
			Handler:    _RaidoChain_GetBlockByHash_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _RaidoChain_GetBalance_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _RaidoChain_GetTransaction_Handler,
		},
		{
			MethodName: "GetStakeDeposits",
			Handler:    _RaidoChain_GetStakeDeposits_Handler,
		},
		{
			MethodName: "GetTransactionsCount",
			Handler:    _RaidoChain_GetTransactionsCount_Handler,
		},
		{
			MethodName: "GetBlocksStartCount",
			Handler:    _RaidoChain_GetBlocksStartCount_Handler,
		},
		{
			MethodName: "ListValidators",
			Handler:    _RaidoChain_ListValidators_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prototype/service.proto",
}

// AttestationClient is the client API for Attestation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AttestationClient interface {
	// SendLegacyTx send transaction data to the node.
	SendLegacyTx(ctx context.Context, in *SendTxRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// SendStakeTx send stake transaction to the node.
	SendStakeTx(ctx context.Context, in *SendTxRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// SendUnstakeTx send stake transaction to the node.
	SendUnstakeTx(ctx context.Context, in *SendTxRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// SendRawTx send raw transaction to the node.
	SendRawTx(ctx context.Context, in *RawTxRequest, opts ...grpc.CallOption) (*ErrorResponse, error)
	// GetFee returns minimal fee price needed to add transaction to the future block.
	GetFee(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NumberResponse, error)
	// GetPendingTransactions returns pending transactions list.
	GetPendingTransactions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TransactionsResponse, error)
}

type attestationClient struct {
	cc grpc.ClientConnInterface
}

func NewAttestationClient(cc grpc.ClientConnInterface) AttestationClient {
	return &attestationClient{cc}
}

func (c *attestationClient) SendLegacyTx(ctx context.Context, in *SendTxRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Attestation/SendLegacyTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attestationClient) SendStakeTx(ctx context.Context, in *SendTxRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Attestation/SendStakeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attestationClient) SendUnstakeTx(ctx context.Context, in *SendTxRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Attestation/SendUnstakeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attestationClient) SendRawTx(ctx context.Context, in *RawTxRequest, opts ...grpc.CallOption) (*ErrorResponse, error) {
	out := new(ErrorResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Attestation/SendRawTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attestationClient) GetFee(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NumberResponse, error) {
	out := new(NumberResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Attestation/GetFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attestationClient) GetPendingTransactions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TransactionsResponse, error) {
	out := new(TransactionsResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Attestation/GetPendingTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AttestationServer is the server API for Attestation service.
// All implementations must embed UnimplementedAttestationServer
// for forward compatibility
type AttestationServer interface {
	// SendLegacyTx send transaction data to the node.
	SendLegacyTx(context.Context, *SendTxRequest) (*ErrorResponse, error)
	// SendStakeTx send stake transaction to the node.
	SendStakeTx(context.Context, *SendTxRequest) (*ErrorResponse, error)
	// SendUnstakeTx send stake transaction to the node.
	SendUnstakeTx(context.Context, *SendTxRequest) (*ErrorResponse, error)
	// SendRawTx send raw transaction to the node.
	SendRawTx(context.Context, *RawTxRequest) (*ErrorResponse, error)
	// GetFee returns minimal fee price needed to add transaction to the future block.
	GetFee(context.Context, *emptypb.Empty) (*NumberResponse, error)
	// GetPendingTransactions returns pending transactions list.
	GetPendingTransactions(context.Context, *emptypb.Empty) (*TransactionsResponse, error)
	mustEmbedUnimplementedAttestationServer()
}

// UnimplementedAttestationServer must be embedded to have forward compatible implementations.
type UnimplementedAttestationServer struct {
}

func (UnimplementedAttestationServer) SendLegacyTx(context.Context, *SendTxRequest) (*ErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendLegacyTx not implemented")
}
func (UnimplementedAttestationServer) SendStakeTx(context.Context, *SendTxRequest) (*ErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendStakeTx not implemented")
}
func (UnimplementedAttestationServer) SendUnstakeTx(context.Context, *SendTxRequest) (*ErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendUnstakeTx not implemented")
}
func (UnimplementedAttestationServer) SendRawTx(context.Context, *RawTxRequest) (*ErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRawTx not implemented")
}
func (UnimplementedAttestationServer) GetFee(context.Context, *emptypb.Empty) (*NumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFee not implemented")
}
func (UnimplementedAttestationServer) GetPendingTransactions(context.Context, *emptypb.Empty) (*TransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPendingTransactions not implemented")
}
func (UnimplementedAttestationServer) mustEmbedUnimplementedAttestationServer() {}

// UnsafeAttestationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AttestationServer will
// result in compilation errors.
type UnsafeAttestationServer interface {
	mustEmbedUnimplementedAttestationServer()
}

func RegisterAttestationServer(s grpc.ServiceRegistrar, srv AttestationServer) {
	s.RegisterService(&Attestation_ServiceDesc, srv)
}

func _Attestation_SendLegacyTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttestationServer).SendLegacyTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Attestation/SendLegacyTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttestationServer).SendLegacyTx(ctx, req.(*SendTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attestation_SendStakeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttestationServer).SendStakeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Attestation/SendStakeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttestationServer).SendStakeTx(ctx, req.(*SendTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attestation_SendUnstakeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttestationServer).SendUnstakeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Attestation/SendUnstakeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttestationServer).SendUnstakeTx(ctx, req.(*SendTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attestation_SendRawTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttestationServer).SendRawTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Attestation/SendRawTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttestationServer).SendRawTx(ctx, req.(*RawTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attestation_GetFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttestationServer).GetFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Attestation/GetFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttestationServer).GetFee(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attestation_GetPendingTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttestationServer).GetPendingTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Attestation/GetPendingTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttestationServer).GetPendingTransactions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Attestation_ServiceDesc is the grpc.ServiceDesc for Attestation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Attestation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rdo.service.Attestation",
	HandlerType: (*AttestationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendLegacyTx",
			Handler:    _Attestation_SendLegacyTx_Handler,
		},
		{
			MethodName: "SendStakeTx",
			Handler:    _Attestation_SendStakeTx_Handler,
		},
		{
			MethodName: "SendUnstakeTx",
			Handler:    _Attestation_SendUnstakeTx_Handler,
		},
		{
			MethodName: "SendRawTx",
			Handler:    _Attestation_SendRawTx_Handler,
		},
		{
			MethodName: "GetFee",
			Handler:    _Attestation_GetFee_Handler,
		},
		{
			MethodName: "GetPendingTransactions",
			Handler:    _Attestation_GetPendingTransactions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prototype/service.proto",
}

// GeneratorClient is the client API for Generator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GeneratorClient interface {
	// UnsafeSend generates signed transaction with given options.
	UnsafeSend(ctx context.Context, in *TxOptionsUnsafeRequest, opts ...grpc.CallOption) (*TxBodyUnsafeResponse, error)
	// CreateStakeTx generates signed stake transaction with given options.
	UnsafeStakeTx(ctx context.Context, in *TxOptionsStakeUnsafeRequest, opts ...grpc.CallOption) (*TxBodyUnsafeResponse, error)
	// CreateUnstakeTx generate signed unstake transaction with given options.
	UnsafeUnstakeTx(ctx context.Context, in *TxOptionsStakeUnsafeRequest, opts ...grpc.CallOption) (*TxBodyUnsafeResponse, error)
	// CreateSend generates signed transaction with given options.
	Send(ctx context.Context, in *TxOptionsRequest, opts ...grpc.CallOption) (*TxBodyResponse, error)
	// CreateStakeTx generates signed stake transaction with given options.
	StakeTx(ctx context.Context, in *TxOptionsStakeRequest, opts ...grpc.CallOption) (*TxBodyResponse, error)
	// CreateUnstakeTx generate signed unstake transaction with given options.
	UnstakeTx(ctx context.Context, in *TxOptionsStakeRequest, opts ...grpc.CallOption) (*TxBodyResponse, error)
}

type generatorClient struct {
	cc grpc.ClientConnInterface
}

func NewGeneratorClient(cc grpc.ClientConnInterface) GeneratorClient {
	return &generatorClient{cc}
}

func (c *generatorClient) UnsafeSend(ctx context.Context, in *TxOptionsUnsafeRequest, opts ...grpc.CallOption) (*TxBodyUnsafeResponse, error) {
	out := new(TxBodyUnsafeResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Generator/UnsafeSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *generatorClient) UnsafeStakeTx(ctx context.Context, in *TxOptionsStakeUnsafeRequest, opts ...grpc.CallOption) (*TxBodyUnsafeResponse, error) {
	out := new(TxBodyUnsafeResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Generator/UnsafeStakeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *generatorClient) UnsafeUnstakeTx(ctx context.Context, in *TxOptionsStakeUnsafeRequest, opts ...grpc.CallOption) (*TxBodyUnsafeResponse, error) {
	out := new(TxBodyUnsafeResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Generator/UnsafeUnstakeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *generatorClient) Send(ctx context.Context, in *TxOptionsRequest, opts ...grpc.CallOption) (*TxBodyResponse, error) {
	out := new(TxBodyResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Generator/Send", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *generatorClient) StakeTx(ctx context.Context, in *TxOptionsStakeRequest, opts ...grpc.CallOption) (*TxBodyResponse, error) {
	out := new(TxBodyResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Generator/StakeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *generatorClient) UnstakeTx(ctx context.Context, in *TxOptionsStakeRequest, opts ...grpc.CallOption) (*TxBodyResponse, error) {
	out := new(TxBodyResponse)
	err := c.cc.Invoke(ctx, "/rdo.service.Generator/UnstakeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeneratorServer is the server API for Generator service.
// All implementations must embed UnimplementedGeneratorServer
// for forward compatibility
type GeneratorServer interface {
	// UnsafeSend generates signed transaction with given options.
	UnsafeSend(context.Context, *TxOptionsUnsafeRequest) (*TxBodyUnsafeResponse, error)
	// CreateStakeTx generates signed stake transaction with given options.
	UnsafeStakeTx(context.Context, *TxOptionsStakeUnsafeRequest) (*TxBodyUnsafeResponse, error)
	// CreateUnstakeTx generate signed unstake transaction with given options.
	UnsafeUnstakeTx(context.Context, *TxOptionsStakeUnsafeRequest) (*TxBodyUnsafeResponse, error)
	// CreateSend generates signed transaction with given options.
	Send(context.Context, *TxOptionsRequest) (*TxBodyResponse, error)
	// CreateStakeTx generates signed stake transaction with given options.
	StakeTx(context.Context, *TxOptionsStakeRequest) (*TxBodyResponse, error)
	// CreateUnstakeTx generate signed unstake transaction with given options.
	UnstakeTx(context.Context, *TxOptionsStakeRequest) (*TxBodyResponse, error)
	mustEmbedUnimplementedGeneratorServer()
}

// UnimplementedGeneratorServer must be embedded to have forward compatible implementations.
type UnimplementedGeneratorServer struct {
}

func (UnimplementedGeneratorServer) UnsafeSend(context.Context, *TxOptionsUnsafeRequest) (*TxBodyUnsafeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsafeSend not implemented")
}
func (UnimplementedGeneratorServer) UnsafeStakeTx(context.Context, *TxOptionsStakeUnsafeRequest) (*TxBodyUnsafeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsafeStakeTx not implemented")
}
func (UnimplementedGeneratorServer) UnsafeUnstakeTx(context.Context, *TxOptionsStakeUnsafeRequest) (*TxBodyUnsafeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsafeUnstakeTx not implemented")
}
func (UnimplementedGeneratorServer) Send(context.Context, *TxOptionsRequest) (*TxBodyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedGeneratorServer) StakeTx(context.Context, *TxOptionsStakeRequest) (*TxBodyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StakeTx not implemented")
}
func (UnimplementedGeneratorServer) UnstakeTx(context.Context, *TxOptionsStakeRequest) (*TxBodyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnstakeTx not implemented")
}
func (UnimplementedGeneratorServer) mustEmbedUnimplementedGeneratorServer() {}

// UnsafeGeneratorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeneratorServer will
// result in compilation errors.
type UnsafeGeneratorServer interface {
	mustEmbedUnimplementedGeneratorServer()
}

func RegisterGeneratorServer(s grpc.ServiceRegistrar, srv GeneratorServer) {
	s.RegisterService(&Generator_ServiceDesc, srv)
}

func _Generator_UnsafeSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxOptionsUnsafeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeneratorServer).UnsafeSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Generator/UnsafeSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeneratorServer).UnsafeSend(ctx, req.(*TxOptionsUnsafeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Generator_UnsafeStakeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxOptionsStakeUnsafeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeneratorServer).UnsafeStakeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Generator/UnsafeStakeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeneratorServer).UnsafeStakeTx(ctx, req.(*TxOptionsStakeUnsafeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Generator_UnsafeUnstakeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxOptionsStakeUnsafeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeneratorServer).UnsafeUnstakeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Generator/UnsafeUnstakeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeneratorServer).UnsafeUnstakeTx(ctx, req.(*TxOptionsStakeUnsafeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Generator_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxOptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeneratorServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Generator/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeneratorServer).Send(ctx, req.(*TxOptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Generator_StakeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxOptionsStakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeneratorServer).StakeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Generator/StakeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeneratorServer).StakeTx(ctx, req.(*TxOptionsStakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Generator_UnstakeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxOptionsStakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeneratorServer).UnstakeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rdo.service.Generator/UnstakeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeneratorServer).UnstakeTx(ctx, req.(*TxOptionsStakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Generator_ServiceDesc is the grpc.ServiceDesc for Generator service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Generator_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rdo.service.Generator",
	HandlerType: (*GeneratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UnsafeSend",
			Handler:    _Generator_UnsafeSend_Handler,
		},
		{
			MethodName: "UnsafeStakeTx",
			Handler:    _Generator_UnsafeStakeTx_Handler,
		},
		{
			MethodName: "UnsafeUnstakeTx",
			Handler:    _Generator_UnsafeUnstakeTx_Handler,
		},
		{
			MethodName: "Send",
			Handler:    _Generator_Send_Handler,
		},
		{
			MethodName: "StakeTx",
			Handler:    _Generator_StakeTx_Handler,
		},
		{
			MethodName: "UnstakeTx",
			Handler:    _Generator_UnstakeTx_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prototype/service.proto",
}
